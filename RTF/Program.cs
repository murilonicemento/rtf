using System.Net.Http.Json;
using System.Text;
using System.Text.Json;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Options;
using RTF.Models;

if (args.Length == 0 || args[0] != "generate")
{
    Console.WriteLine("Comando não reconhecido.");

    return;
}

Console.ForegroundColor = ConsoleColor.Yellow;
Console.WriteLine("⚠️");
Console.WriteLine("Make sure Anki is running and AnkiConnect is enabled.");
Console.WriteLine("The application expects AnkiConnect to be accessible at http://localhost:8765.");
Console.WriteLine("⚠️");
Console.ResetColor();

Console.WriteLine("Hey. What is the file path to generate the flashcards?");

var filePath = Console.ReadLine();

while (string.IsNullOrEmpty(filePath))
{
    Console.WriteLine("File path can't be blank. What is the file path to generate the flashcards?");
    filePath = Console.ReadLine();
}

Console.Clear();

var userRootPath = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);
var path = $"{userRootPath}\\{filePath}";

var fileExists = File.Exists(path);

if (!fileExists)
{
    Console.WriteLine("File not exists.");

    return;
}

var summary = await File.ReadAllTextAsync(path);

if (string.IsNullOrEmpty(summary))
{
    Console.WriteLine("File content is empty.");

    return;
}

var host = Host.CreateDefaultBuilder(args)
    .ConfigureAppConfiguration((context, config) =>
    {
        config.AddJsonFile("appsettings.json", optional: false, reloadOnChange: true);
    })
    .ConfigureServices((context, services) =>
    {
        services.Configure<GeminiOptions>(context.Configuration.GetSection("GeminiOptions"));
    })
    .Build();

var geminiOptions = host.Services.GetRequiredService<IOptions<GeminiOptions>>().Value;

if (string.IsNullOrEmpty(geminiOptions.ApiKey))
{
    Console.WriteLine("API Key not provided.");

    return;
}

if (string.IsNullOrEmpty(geminiOptions.Url))
{
    Console.WriteLine("Url not provided.");

    return;
}

var deckName = string.Empty;

while (string.IsNullOrEmpty(deckName))
{
    Console.WriteLine("What is the deck name to save the flashcards?");

    deckName = Console.ReadLine();
}

Console.Clear();

var cts = new CancellationTokenSource();
var deckLoading = ShowLoading("Generating", cts.Token);
var httpClient = new HttpClient();

const string ankiUrl = "http://localhost:8765";

var ankiRequestGetDecksName = new AnkiRequestGetDecksName
{
    Action = AnkiActionOptions.DeckNames.ToActionString(),
};

var ankiGetDecksNameContent =
    new StringContent(JsonSerializer.Serialize(ankiRequestGetDecksName), Encoding.UTF8, "application/json");
var ankiGetDecksNamesResponse = await httpClient.PostAsync(ankiUrl, ankiGetDecksNameContent);

ankiGetDecksNamesResponse.EnsureSuccessStatusCode();

var decksNamesString = await ankiGetDecksNamesResponse.Content.ReadAsStringAsync();
var decksNameList = JsonSerializer.Deserialize<AnkiResponse<List<string>>>(decksNamesString);

if (decksNameList?.Error is not null)
{
    Console.WriteLine("Error occurred while validating deck name.");

    return;
}

var containsDeck = decksNameList != null && decksNameList.Result.Contains(deckName);

if (decksNameList?.Error is not null)
{
    Console.WriteLine($"Erro while getting the decks name: {string.Join(" | ", decksNameList.Error)}");

    return;
}

if (!containsDeck)
{
    Console.WriteLine("Deck not exist.");

    return;
}

var prompt =
    $@"Based on the summary below, generate a JSON object for the ""params"" field used in the AnkiConnect ""addNotes"" action. 
Return only the JSON object with a ""notes"" array, where each note has the following properties:

- ""deckName"": ""{deckName}""
- ""modelName"": always ""Básico""
- ""fields"": an object with ""Frente"" (question) and ""Verso"" (answer)
- ""options"": with ""allowDuplicate"" set to false
- ""tags"": an array containing only the string ""auto generated by AI""

Return a valid JSON object containing only the ""params"" with the list of notes. Do not include any explanations, comments, or additional text.

Summary to generate flashcards from:
{summary}";

var requestBody = new
{
    contents = new[]
    {
        new
        {
            parts = new[]
            {
                new { text = prompt }
            }
        }
    }
};

var geminiResponse = await httpClient.PostAsJsonAsync($"{geminiOptions.Url}?key={geminiOptions.ApiKey}", requestBody);

if (!geminiResponse.IsSuccessStatusCode)
{
    Console.WriteLine("An error occured when generate flashcards.");

    return;
}

var result = await geminiResponse.Content.ReadFromJsonAsync<GeminiResponse>();

if (result?.Candidates is not { Count: > 0 })
{
    var errorMessage = await geminiResponse.Content.ReadAsStringAsync();

    Console.WriteLine($"An error occured when generate flashcards: {errorMessage}");

    return;
}

var responseContent = result.Candidates[0].Content.Parts[0].Text.Replace("```", "").Replace("json", "");
var ankiNotesParams = JsonSerializer.Deserialize<AnkiNoteParams>(responseContent);
var ankiRequestAddNote = new AnkiRequestAddNote
{
    Action = AnkiActionOptions.AddNotes.ToActionString(),
    Params = new { notes = ankiNotesParams?.Notes }
};

var ankiAddNoteContent =
    new StringContent(JsonSerializer.Serialize(ankiRequestAddNote), Encoding.UTF8, "application/json");
var ankiAddNoteResponse = await httpClient.PostAsync(ankiUrl, ankiAddNoteContent);

ankiAddNoteResponse.EnsureSuccessStatusCode();

var ankiAddNotesStringResult = await ankiAddNoteResponse.Content.ReadAsStringAsync();
var ankiAddNotesResult = JsonSerializer.Deserialize<AnkiResponse<List<long>>>(ankiAddNotesStringResult);

cts.Cancel();

await deckLoading;

if (ankiAddNotesResult?.Error is not null)
{
    Console.WriteLine("Error occurred while adding flashcards to Anki.");

    return;
}

Console.WriteLine("Operation performed successfully. Sayonara!");

return;

static async Task ShowLoading(string message, CancellationToken token)
{
    var sequence = new[] { "|", "/", "-", "\\" };
    var counter = 0;

    Console.Write($"{message} ");

    while (!token.IsCancellationRequested)
    {
        Console.Write(sequence[counter % sequence.Length]);
        Console.SetCursorPosition(Console.CursorLeft - 1, Console.CursorTop);

        counter++;

        await Task.Delay(100);
    }

    Console.Clear();
}