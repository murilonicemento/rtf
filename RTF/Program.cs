using System.Net.Http.Json;
using System.Text;
using System.Text.Json;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Options;
using RTF.Models;

Console.WriteLine("Hey. What is the file path to generate the flashcards?");

var filePath = Console.ReadLine();

while (string.IsNullOrEmpty(filePath))
{
    Console.WriteLine("File path can't be blank. What is the file path to generate the flashcards?");
    filePath = Console.ReadLine();
}

var userRootPath = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);
var path = $"{userRootPath}\\{filePath}";

var fileExists = File.Exists(path);

if (!fileExists)
{
    Console.WriteLine("File not exists.");

    return;
}

var summary = await File.ReadAllTextAsync(path);

if (string.IsNullOrEmpty(summary))
{
    Console.WriteLine("File content is empty.");

    return;
}

var host = Host.CreateDefaultBuilder(args)
    .ConfigureAppConfiguration((context, config) =>
    {
        config.AddJsonFile("appsettings.json", optional: false, reloadOnChange: true);
    })
    .ConfigureServices((context, services) =>
    {
        services.Configure<GeminiOptions>(context.Configuration.GetSection("GeminiOptions"));
    })
    .Build();

var geminiOptions = host.Services.GetRequiredService<IOptions<GeminiOptions>>().Value;

if (string.IsNullOrEmpty(geminiOptions.ApiKey))
{
    Console.WriteLine("API Key not provided.");

    return;
}

if (string.IsNullOrEmpty(geminiOptions.Url))
{
    Console.WriteLine("Url not provided.");

    return;
}

var deckName = string.Empty;

while (string.IsNullOrEmpty(deckName))
{
    Console.WriteLine("What is the deck name to save the flashcards?");

    deckName = Console.ReadLine();
}

var httpClient = new HttpClient();

const string ankiUrl = "http://localhost:8765";

var ankiRequestGetDecksName = new AnkiRequestGetDecksName
{
    Action = AnkiActionOptions.DeckNames.ToActionString(),
};

var ankiGetDecksNameContent =
    new StringContent(JsonSerializer.Serialize(ankiRequestGetDecksName), Encoding.UTF8, "application/json");
var ankiGetDecksNamesResponse = await httpClient.PostAsync(ankiUrl, ankiGetDecksNameContent);

ankiGetDecksNamesResponse.EnsureSuccessStatusCode();

var decksNamesString = await ankiGetDecksNamesResponse.Content.ReadAsStringAsync();
var decksNameList = JsonSerializer.Deserialize<AnkiResponseGetDecksName>(decksNamesString);
var containsDeck = decksNameList != null && decksNameList.Result.Contains(deckName);

if (!string.IsNullOrEmpty(decksNameList?.Error))
{
    Console.WriteLine($"Erro while getting the decks name: {decksNameList.Error}");

    return;
}

if (!containsDeck)
{
    var createNewDeck = string.Empty;

    while (string.IsNullOrEmpty(createNewDeck))
    {
        Console.WriteLine("Deck not exist, want to create a new deck (y/n)?");

        createNewDeck = Console.ReadLine();
    }

    if (createNewDeck.Equals("n", StringComparison.OrdinalIgnoreCase))
    {
        Console.WriteLine("Want to rename the deck (y/n)?");

        var renameDeck = Console.ReadLine();

        if (string.IsNullOrEmpty(renameDeck) || renameDeck.Equals("n", StringComparison.OrdinalIgnoreCase))
            return;

        if (renameDeck.Equals("y", StringComparison.OrdinalIgnoreCase))
        {
            Console.WriteLine("New deck name:");

            var newDeckName = Console.ReadLine();

            while (string.IsNullOrEmpty(newDeckName))
            {
                Console.WriteLine("Deck name can't be blank. Type a valid deck name:");

                newDeckName = Console.ReadLine();
            }

            deckName = newDeckName;
        }
    }
}

var prompt =
    $@"Based on the summary below, generate a JSON object for the ""params"" field used in the AnkiConnect ""addNotes"" action. 
Return only the JSON object with a ""notes"" array, where each note has the following properties:

- ""deckName"": ""{deckName}""
- ""modelName"": always ""Basic""
- ""fields"": an object with ""Front"" (question) and ""Back"" (answer)
- ""options"": with ""allowDuplicate"" set to false
- ""tags"": an array containing only the string ""auto generated by AI""

Return a valid JSON object containing only the ""params"" with the list of notes. Do not include any explanations, comments, or additional text.

Summary to generate flashcards from:
{summary}";

var requestBody = new
{
    contents = new[]
    {
        new
        {
            parts = new[]
            {
                new { text = prompt }
            }
        }
    }
};

var geminiResponse = await httpClient.PostAsJsonAsync($"{geminiOptions.Url}{geminiOptions.ApiKey}", requestBody);

if (!geminiResponse.IsSuccessStatusCode)
{
    Console.WriteLine("An error occured when generate flashcards.");

    return;
}

var result = await geminiResponse.Content.ReadFromJsonAsync<GeminiResponse>();

if (result?.Candidates is not { Count: > 0 })
{
    var errorMessage = await geminiResponse.Content.ReadAsStringAsync();

    Console.WriteLine($"An error occured when generate flashcards: {errorMessage}");

    return;
}

var responseContent = result.Candidates[0].Content.Parts[0].Text;

var ankiRequestAddNote = new AnkiRequestAddNote
{
    Action = AnkiActionOptions.AddNote.ToActionString(),
    Params = new { responseContent }
};

var ankiAddNoteContent =
    new StringContent(JsonSerializer.Serialize(ankiRequestAddNote), Encoding.UTF8, "application/json");
var ankiAddNoteResponse = await httpClient.PostAsync(ankiUrl, ankiAddNoteContent);

ankiAddNoteResponse.EnsureSuccessStatusCode();